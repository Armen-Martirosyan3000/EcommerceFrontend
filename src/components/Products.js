import { useEffect, useState } from "react";
import styled from "styled-components";
import { popularProducts } from "../data";
import Product from "./Product";
import axios from "axios";
import { mobile } from "../responsive";

//flex-wrap-ը CSS հատկությունը սահմանում է , թե արդյոք ճկուն տարրերը սեղմվում են մեկ տողի վրա, թե կարող են փաթաթվել մի քանի տողերի վրա: Եթե ​​փաթաթումը թույլատրվում է, այն սահմանում է տողերի կուտակման ուղղությունը: wrap   flex տարրերը բաժանվում են մի քանի տողերի: cross-start կամ համարժեք է սկզբին կամ կախված արժեքից առաջ , իսկ խաչաձև վերջ(cross-end) հակադրվում է նշված խաչաձև մեկնարկին(cross-start) :flex-direction
const Container = styled.div`
    padding: 20px;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    ${mobile({ padding: "5px"})}
`;

// const Products = ({ cat, filters, sort }) => {
//  // console.log(cat, filters, sort )
// const [products, setProducts] = useState([]);//այստեղ մենք կսահմանենք մեր ապրանքները, դրա համար ստեղծում ենք այս useState([])-ը ու սկզբնական արժեքը կլինի դատարկ զանգված
// const [filteredProducts, setFilteredProducts] = useState([]);
// useEffect(() => {//useEffect-ի կախվածությունը(որպես դիփենդեսի, երկրորդ արժեք) դնում ենք cat-ը(կատեգորիան), որը նշանակում է երբ կփոխվի կատեգորիան կաշխատի այս ֆունկցիան, իսկ այս ֆունկցիայի միջոցով մենք կստանանք ապրանքերը մեր API-ից, դրա համար մենք հարցում կանենք դատա ստանալու և հրապարակելու համար։ Հարցում կատարելու համար մենք օգտագործում ենք axios
//       const getProducts = async () => {//ապրանքների հարցման փոփոխականը նշանակում ենք՝ getProducts, դա ասինխրոն ֆունկցիա է որովհետև մենք անում ենք հարցումներ(request) մեր API-ին ուստի դա կլին try catch blok
//         try {
//           const res = await axios.get(//await-ի միջոցով կսպասի մեր հարցմանը, ու մենք axios-ով հարցում կանենք ու հիշում ենք որ մեր տվյալները մենք վերցնում ենք get մեթոդով
//             "http://localhost:9000/api/products?category=tshirt"//մեր URL հասցեն է՝ http://localhost:9000/api/products?category=${cat}
              
//           );
//         console.log(res)//
//         } catch (err) {}
//       };
//       getProducts();
//     }, [cat]);
//   return (
//     <Container>
//       {popularProducts.map((item) => (
		
//         <Product item={item} key={item.id} />
//       ))}
//     </Container>
//   );
// };

//cat, filters, sort -ը ընդունում ենք որպես props, որոնք փոխացվել են ProductList page-ից, այս՝ cat, filters, sort բոլորը պատրաստ են որպեսզի վերցնեն մեր տվյալները(data-ները)
const Products = ({ cat, filters, sort }) => {
  //այստեղ մենք կստանանք մեր data-ները
  const [products, setProducts] = useState([]);//այստեղ մենք կսահմանենք մեր ապրանքները, դրա համար ստեղծում ենք այս useState([])-ը ու սկզբնական արժեքը կլինի դատարկ զանգված
  const [filteredProducts, setFilteredProducts] = useState([]);//սա կլինի մեր ֆիլտրված ապրանքները, որովհետև ամեն անգամ երբ մենք ամեն անգամ փոխում ենք մեր ֆիլտրը մենք կթարմացնենք այդ ֆիլտրված ապրանքները՝filteredProducts

  useEffect(() => {//useEffect-ի կախվածությունը(որպես դիփենդեսի, երկրորդ արժեք) դնում ենք cat-ը(կատեգորիան), որը նշանակում է երբ կփոխվի կատեգորիան կաշխատի այս ֆունկցիան, իսկ այս ֆունկցիայի միջոցով մենք կստանանք ապրանքերը մեր API-ից, դրա համար մենք հարցում կանենք դատա ստանալու և հրապարակելու համար։ Հարցում կատարելու համար մենք օգտագործում ենք axios
    const getProducts = async () => {//ապրանքների հարցման փոփոխականը նշանակում ենք՝ getProducts, դա ասինխրոն ֆունկցիա է որովհետև մենք անում ենք հարցումներ(request) մեր API-ին ուստի դա կլին try catch blok
      try {
        const res = await axios.get(//await-ի միջոցով կսպասի մեր հարցմանը, ու մենք axios-ով հարցում կանենք ու հիշում ենք որ մեր տվյալները մենք վերցնում ենք get մեթոդով
          cat// սա պայման է որով ասվում է եթե կա կատեգորիա(cat) օգտագործիր այս URL-ը՝ http://localhost:9000/api/products?category=${cat}
            ? `http://localhost:9000/api/products?category=${cat}`// {cat}-ը փոխանցվելա props-ով ProductList page-ից
            : "http://localhost:9000/api/products" //հակառակ դեպքում եթե կատեգորիա չկա տվյալները(data) ներկայացրեք այս URL-ից՝http://localhost:9000/api/products, այսինքն այն ցույց կտա բոլոր ապրանքները
        );
        setProducts(res.data);//սրանով թարմացնում ենք մեր ապրանքները
      } catch (err) {}
    };
    getProducts();//այստեղեվ մենք կանչում ենք ֆունկցիան որ ստանանք ապրանքները
  }, [cat]);

//այսպիսով վերևի useEffect-ով մենք ստանում ենք մեր ապրանքները, մենք կարող ենք նրանց օգտագործենք ու ամեն անգամ երբ մենք կփոխենք ինչ որ ֆիլտր մենք կսահմանենք մեր ֆիլտրացված ապրանքները՝filteredProducts, որպեսզի մենք դա անենք մենք կստեղծենք դրա համար ևս մեկ useEffect hook

  useEffect(() => {
    cat &&   //մենք այստեղ ասում ենք եթե առկա է կատեգորիա(cat) սահմանել ֆիլտրացված ապրանքները՝setFilteredProducts, և մենք կտեղադրենք նրանց ֆիլտրների օգնությամբ
      setFilteredProducts(
        products.filter((item) =>//ստեղով մենք կֆիլտրենք ու կընդունենք յուրաքանչյուր էլեմենտ, կստուգենք արդյող տվյալ էլեմենտը ունի այդ ֆիլտրները(օրինակ տվյալ գույնը կամ չափսը) թե ոչ, մենք կվերցնենք մեր ֆիլտրները ու կնայենք յուրաքանչյուր բանալիի ու արժեքի ներսը, օրինակ գույնը դեղին է իսկ չափսը M ու այդ ժամանակ մեր բանալիներն են գույնը և չափսը, իսկ մեր արժեքները կլինեն դեղինը և M-ը ու դրանից հետո մենք կտեղադրենք այդ էլեմենտները ունեցող ապրանքների հետ, եթե որևէ էլեմենտ ունի այդ ֆիլտրները(այդ բանալին ու այդ արժեքը) մենք կցուցադրենք այդ ապրանքները
          //Object.entries() Մեթոդ Object.entries() մեթոդն օգտագործվում է վերադարձնելու զանգված, որը բաղկացած է օբյեկտի թվարկելի հատկություն [key, value] զույգերից,Object.entries()-ն օգտագործվում է օբյեկտի հետ կապված հատկությունները ցուցակագրելու համար:Object.entries()-ն օգտագործվում է օբյեկտի բոլոր [key,value] զույգերը ցուցակագրելու համար: Ավելին կարող ենք կարդալ teorea.txt ֆայլում
        //Մեթոդը Object.entries()վերադարձնում է տվյալ օբյեկտի սեփական թվարկվող լարային ստեղներով հատկության բանալի-արժեք զույգերի զանգված:
          Object.entries(filters).every(([key, value]) =>//Object.entries-ի մեջ վերցնում ենք մեր ֆիլտրները(filters) ու ամեն էլեմենտի համար մենք կվերցնենք բանալին և արժեքը([key, value]) ու
            item[key].includes(value)// դրանից հետո այստեղ ասում ենք եթե էլեմենտի բանալին ներառում է(includes) տվյալ արժեքը մենք կֆիլտրենք նրան
          )
        )
      );
  }, [products, cat, filters]);//որպես դիփենդեսի(կախվածություն) մենք տալիս ենք props-ով ստացած արժեքները՝[products, cat, filters]

  //սրա միջոցով իրականացվում է ապրանքների սորտավորում, արժեքների ըստ աճման կամ նվազման, կամ նորագույն ապրանքների գծով
  useEffect(() => {
    if (sort === "newest") {//սա պայման է որ եթե նոր՝newest ապրանքներն է նշված
      setFilteredProducts((prev) =>
        [...prev].sort((a, b) => a.createdAt - b.createdAt)//սա՝...prev(նախորդ) հիմնականում պահում է իր մեջ մեր ֆիլտրի բոլոր էլեմենտները, որից հետո մենք տեսակավորում ենք՝.sort((a, b) => a.createdAt - b.createdAt), սա տեսակավորման ալգորիթմ է, այն համամատում է 2 տարր զանգվածի ներսում որտեղ կնայվի ապրանքի ավելացման ամսաթվին, եթե առաջինը մեծ է այն կցուցադրի առավել մոտիկ ստեղծված  էլեմենտները
      );
    } else if (sort === "asc") {//սա պայման է որ եթե նշված է ըստ աճման՝asc 
      setFilteredProducts((prev) =>
        [...prev].sort((a, b) => a.price - b.price)//այս ալգորիթմի համաձայն ապրանքների կցուցադրվեն ըստ աճման
      );
    } else {
      setFilteredProducts((prev) =>
        [...prev].sort((a, b) => b.price - a.price)//այս ալգորիթմի համաձայն ապրանքների կցուցադրվեն ըստ նվազման
      );
    }
  }, [sort]);//այստեղ մեր կախվածությունը(դիփենդեսին) կլինի props-ով ստացած մեր [sort]-ը

   return (


    <Container>
      {/* սրա միջոցով գլխավոր էջի ներքևի հատվածում ցուցադրվում են բոլոր ապրանքները */}
      {cat//այստեղ նշում ենք պայման եթե կա կատեգորիա օգտագործեք այդ ֆիլտրված զանգվածը, իսկ եթե չկա
// Երբ օգտագործում ես map այդ ժամանակ պարտադիր է օգտագործել եզակի բանալի, որը տվյալ դեպքում, զանգվածում գտնվող օբյեկտների id-ն է
        ? filteredProducts.map((item) => <Product item={item} key={item.id} />)
        : products//իսկ եթե չկա կատեգորիա այն կօգտագործի ապրանքների զանգվածը
            .slice(0, 15)//սրանով սահմանվում է որպեսզի եթե զանգվածում լինեն շատ նկարներ,ցուցադրվի միայն 15 հատը
            .map((item) => <Product item={item} key={item.id} />)}
    </Container>
  );
};


export default Products;


